.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Examples 3pm"
.TH Examples 3pm "2016-12-12" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "PSPP::Examples"
.IX Header "PSPP::Examples"
This page shows some simple examples of using the \s-1PSPP\s0 module.
See \s-1PSPP\s0 for details on each of the subroutines.
.SS "A Simple example"
.IX Subsection "A Simple example"
This example creates a system file called \fIfoo.sav\fR, containing one 
variable called \*(L"id\*(R".  It contains no data.
.PP
.Vb 1
\&        use PSPP;
\&
\&        my $dict = PSPP::Dict\->new ();
\&        my $var = PSPP::Var\->new ($dict, "id");
\&
\&        my $sysfile = PSPP::Sysfile\->new ("foo.sav", $dict);
\&        $sysfile\->close();
.Ve
.SS "A slightly more complex example"
.IX Subsection "A slightly more complex example"
In this example there are three variables, called \*(L"id\*(R", \*(L"name\*(R" and \*(L"dob\*(R".
Their formats are F2.0, A80 and \s-1DATETIME17\s0 respectively.
.PP
.Vb 1
\&        use PSPP;
\&
\&        my $dict = PSPP::Dict\->new ();
\&        PSPP::Var\->new ($dict, "id",
\&                   (fmt=>PSPP::Fmt::F, width=>2, decimals=>0) );
\&        
\&        PSPP::Var\->new ($dict, "name", (fmt=>PSPP::Fmt::A, width=>80) );
\&        PSPP::Var\->new ($dict, "dob",  (fmt=>PSPP::Fmt::DATETIME) );
\&
\&        my $sysfile = PSPP::Sysfile\->new ("foo.sav", $dict);
\&        $sysfile\->close();
.Ve
.SS "Changing the properties of variables"
.IX Subsection "Changing the properties of variables"
After a variable has been created, parameters may be set for it.
.PP
.Vb 1
\&        use PSPP;
\&
\&        my $dict = PSPP::Dict\->new ();
\&        my $var1 = PSPP::Var\->new ($dict, "id");
\&
\&        $var1\->set_label ("A unique identifier");
\&        $var1\->add_value_label (0, "Zero");
\&        $var1\->add_value_label (1, "One");
.Ve
.SS "Appending data to the file"
.IX Subsection "Appending data to the file"
When a file is created, it contains no data.  Data is added by
appending cases to the file.
.PP
This example creates a file with 3 cases.
.PP
.Vb 1
\&        use PSPP;
\&
\&        my $dict = PSPP::Dict\->new ();
\&        PSPP::Var\->new ($dict, "id", 
\&           (fmt=>PSPP::Fmt::F, width=>2, decimals=>0) );
\&
\&        PSPP::Var\->new ($dict, "name", (fmt=>PSPP::Fmt::A, width=>8) );
\&
\&        my $sysfile = PSPP::Sysfile\->new ("foo.sav", $dict);
\&
\&        $sysfile\->append_case ( [1, "Alf"] );
\&        $sysfile\->append_case ( [2, "Bert"] );
\&        $sysfile\->append_case ( [3, "Charlie"] );
\&
\&        $sysfile\->close();
.Ve
.SS "Variables with differing input and output formats"
.IX Subsection "Variables with differing input and output formats"
By default,  a variable's output format corresponds to the input format.
However, the output format may be changed after the variable has 
been created.
.PP
This example shows how  to create a \s-1DATETIME\s0 variable using the current time
as its value.  Since pspp uses a different epoch to perl, the constant 
\&\s-1PSPP::PERL_EPOCH\s0 needs to be added to the value returned from \fItime()\fR, in order 
that it be correctly represented by pspp.
.PP
.Vb 1
\&        use PSPP;
\&
\&        my $dict = PSPP::Dict\->new ();
\&
\&        my $var1 = PSPP::Var\->new ($dict, "entrytime", 
\&                (fmt=>PSPP::Fmt::F) );
\&
\&        $var1\->set_output_format ( (fmt=>PSPP::Fmt::DATETIME, width=>20) );
\&
\&        my $sysfile = PSPP::Sysfile\->new ("foo.sav", $dict);
\&
\&        my $now = time ();
\&
\&        $sysfile\->append_case ( [ $now  + PSPP::PERL_EPOCH]  ) 
\&                || die "Cant write case";
\&        
\&        $sysfile\->close();
.Ve
.SS "Reading data"
.IX Subsection "Reading data"
Data can be read from a system file or other source:
.PP
.Vb 1
\&        use PSPP;
\&
\&        my $sf = PSPP::Reader\->open ("foo.sav");
\&
\&        my $dict = $sf\->get_dict ();
.Ve
.PP
Once opened, the dictionary can be used like any other.
.PP
.Vb 3
\&        for ($v = 0 ; $v < $dict\->get_var_cnt() ; $v++)
\&        {
\&            my $var = $dict\->get_var ($v);
\&
\&            # Print the variables
\&            my $name = $var\->get_name ();
\&            my $label = $var\->get_label ();
\&            print "Var: $name, Label: $label\en";
\&
\&            # Retrieve and print the value labels
\&            my $vl = $var\->get_value_labels ();
\&            print "$_: $vl\->{$_}\en" for keys %$vl;
\&        }
.Ve
.PP
Reading of data must be done sequentially using the \f(CW\*(C`get_next_case\*(C'\fR method.
.PP
.Vb 9
\&        while (my $c = $sf\->get_next_case () )
\&        {
\&            my $v;
\&            for ($v = 0; $v < $dict\->get_var_cnt(); $v++)
\&            {
\&                print "val$v: @$c[$v] ";
\&            }
\&            print "\en";
\&        }
.Ve
