.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PSPP 3pm"
.TH PSPP 3pm "2016-12-12" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PSPP\-Perl \- Perl extension to PSPP
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use PSPP;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PSPP-Perl provides an interface to the libraries used by pspp to read and
write system files.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "PROGRAMMER'S INTERFACE"
.IX Header "PROGRAMMER'S INTERFACE"
The subroutines in this package return zero or unref on error.
When errors occur, a string describing the error is written 
to \f(CW$PSPP::errstr\fR.
.SS "PSPP::Dict::new"
.IX Subsection "PSPP::Dict::new"
Creates a new dictionary.  This returned dictionary will be empty.
Returns undef on failure.
.PP
\fIset_documents ($string)\fR
.IX Subsection "set_documents ($string)"
.PP
Sets the documents (comments) to \f(CW\*(C`string\*(C'\fR.
.PP
\fIadd_document ($string)\fR
.IX Subsection "add_document ($string)"
.PP
Appends \f(CW\*(C`string\*(C'\fR to the documents.
.PP
\fIclear_documents ()\fR
.IX Subsection "clear_documents ()"
.PP
Removes all documents.
.PP
\fIset_weight ($var)\fR
.IX Subsection "set_weight ($var)"
.PP
Sets the weighting variable to \f(CW\*(C`var\*(C'\fR.
.PP
\fIget_var_cnt ()\fR
.IX Subsection "get_var_cnt ()"
.PP
Returns the number of variables in the dictionary.
.PP
\fIget_var ($idx)\fR
.IX Subsection "get_var ($idx)"
.PP
Returns the \f(CW\*(C`idx\*(C'\fRth variable from the dictionary.
Returns undef if \f(CW\*(C`idx\*(C'\fR is greater than or equal to the number
of variables in the dictionary.
.PP
\fIget_var_by_name ($name)\fR
.IX Subsection "get_var_by_name ($name)"
.PP
Returns the variable from the dictionary whose name is \f(CW\*(C`name\*(C'\fR.
If there is no such variable, a null reference will be returned.
.SS "PSPP::Fmt"
.IX Subsection "PSPP::Fmt"
Contains constants used to denote variable format types.  
The identifiers are the same as  those used in pspp to denote formats.
For  example \f(CW\*(C`PSPP::Fmt::F\*(C'\fR defines floating point format, and
\&\f(CW\*(C`PSPP::Fmt::A\*(C'\fR denotes string format.
.SS "PSPP::Var"
.IX Subsection "PSPP::Var"
\fInew ($dict, \f(CI$name\fI, \f(CI%input_fmt\fI)\fR
.IX Subsection "new ($dict, $name, %input_fmt)"
.PP
Creates and returns a new variable in the dictionary \f(CW\*(C`dict\*(C'\fR.  The 
new variable will have the name \f(CW\*(C`name\*(C'\fR.  \f(CW\*(C`name\*(C'\fR must be a valid \s-1UTF8\s0 string.
The input format is set by the \f(CW\*(C`input_fmt\*(C'\fR parameter 
(See \*(L"PSPP::Fmt\*(R").
By default, the write and print formats are the same as the input format.
The write and print formats may be changed (See \*(L"set_write_format\*(R"), 
\&\*(L"set_print_format\*(R").  The input format may not be changed after
the variable has been created.
If the variable cannot be created, undef is returned.
.PP
\fIset_label ($label)\fR
.IX Subsection "set_label ($label)"
.PP
Sets the variable label to \f(CW\*(C`label\*(C'\fR, which must be a valid \s-1UTF8\s0 string.
.PP
\fIset_write_format (%fmt)\fR
.IX Subsection "set_write_format (%fmt)"
.PP
Sets the write format to \f(CW\*(C`fmt\*(C'\fR. <fmt> is a hash containing the keys:
.IP "\s-1FMT\s0" 2
.IX Item "FMT"
A constant denoting the format type.  See \*(L"PSPP::Fmt\*(R".
.IP "decimals" 2
.IX Item "decimals"
An integer denoting the number of decimal places for the format.
.IP "width" 2
.IX Item "width"
An integer denoting the width of the format.
.PP
On error the subroutine returns zero.
.PP
\fIset_print_format (%fmt)\fR
.IX Subsection "set_print_format (%fmt)"
.PP
Sets the print format to \f(CW\*(C`fmt\*(C'\fR.
On error the subroutine returns zero.
.PP
\fIget_write_format ()\fR
.IX Subsection "get_write_format ()"
.PP
Returns a reference to a hash containing the write format for the variable.
.PP
\fIget_print_format ()\fR
.IX Subsection "get_print_format ()"
.PP
Returns a reference to a hash containing the print format for the variable.
.PP
\fIset_output_format (%fmt)\fR
.IX Subsection "set_output_format (%fmt)"
.PP
Sets the write and print formats to \f(CW\*(C`fmt\*(C'\fR.  This is the same as
calling set_write_format followed by set_print_format.
On error the subroutine returns zero.
.PP
\fIclear_value_labels ()\fR
.IX Subsection "clear_value_labels ()"
.PP
Removes all value labels from the variable.
.PP
\fIadd_value_label ($key, \f(CI$label\fI)\fR
.IX Subsection "add_value_label ($key, $label)"
.PP
Adds the value label \f(CW\*(C`label\*(C'\fR to the variable for the value \f(CW\*(C`key\*(C'\fR.
\&\f(CW\*(C`label\*(C'\fR must be a valid \s-1UTF8\s0 string.
On error the subroutine returns zero.
.PP
\fIadd_value_labels (@array)\fR
.IX Subsection "add_value_labels (@array)"
.PP
\fIset_value_labels ($key, \f(CI$label\fI)\fR
.IX Subsection "set_value_labels ($key, $label)"
.PP
\&\f(CW\*(C`Set_value_labels\*(C'\fR is identical to calling \*(L"clear_value_labels\*(R"
followed by \*(L"add_value_labels\*(R".
On error the subroutine returns zero.
.PP
\fIset_missing_values ($val1 [, \f(CI$val2\fI[, \f(CI$val3\fI] ])\fR
.IX Subsection "set_missing_values ($val1 [, $val2[, $val3] ])"
.PP
Sets the missing values for the variable.  
No more than three missing values may be specified.
.PP
\fI\fIget_attributes()\fI\fR
.IX Subsection "get_attributes()"
.PP
Returns a reference to a hash of the custom variable attributes.
Each value of the hash is a reference to an array containing the 
attribute values.
.PP
\fIget_name ()\fR
.IX Subsection "get_name ()"
.PP
Returns the name of the variable.
.PP
\fIget_label ()\fR
.IX Subsection "get_label ()"
.PP
Returns the label of the variable or undef if there is no label.
.PP
\fIget_value_labels ()\fR
.IX Subsection "get_value_labels ()"
.PP
Returns a reference to a hash containing the value labels for the variable.
The hash is keyed by data values which correpond to the labels.
.SS "PSPP::Sysfile"
.IX Subsection "PSPP::Sysfile"
\fInew ($filename, \f(CI$dict\fI [,%opts])\fR
.IX Subsection "new ($filename, $dict [,%opts])"
.PP
Creates a new system file from the dictionary \f(CW\*(C`dict\*(C'\fR.  The file will
be written to the file called \f(CW\*(C`filename\*(C'\fR. The string \f(CW\*(C`filename\*(C'\fR must 
be encoded in \s-1UTF\-8.
\&\s0\f(CW\*(C`opt\*(C'\fR, if specified, is a hash containing optional parameters for the
system file.  Currently, the only supported parameter is
\&\f(CW\*(C`compress\*(C'\fR. If \f(CW\*(C`compress\*(C'\fR is non zero, then the system file written
will be in the compressed format.
On error, undef is returned.
.PP
\fIappend_case (@case)\fR
.IX Subsection "append_case (@case)"
.PP
Appends a case to the system file.
\&\f(CW\*(C`Case\*(C'\fR is an array of scalars, each of which are the values of 
the variables in the dictionary corresponding to the system file.
If the case contains strings, then the strings must be \s-1UTF8\s0 encoded.
The special value \f(CW\*(C`PSPP::SYSMIS\*(C'\fR may be used to indicate that a value
is system missing.
If the array contains less elements than variables in the dictionary,
remaining values will be set to system missing.
.PP
\fIclose ()\fR
.IX Subsection "close ()"
.PP
Closes the system file.
.PP
This subroutine closes the system file and flushes it to disk.  No
further cases may be written once the file has been closed.
The system file will be automatically closed when it goes out of scope.
.SS "PSPP::Reader"
.IX Subsection "PSPP::Reader"
\fIopen ($filename)\fR
.IX Subsection "open ($filename)"
.PP
Opens a system file for reading.
.PP
Open is used to read data from an existing system file. 
It creates and returns a PSPP::Reader object which can be used to read 
data and dictionary information from \f(CW\*(C`filename\*(C'\fR.  The string \f(CW\*(C`filename\*(C'\fR 
must be in \s-1UTF\-8\s0 encoding.
.PP
\fIget_case_cnt ()\fR
.IX Subsection "get_case_cnt ()"
.PP
Returns the number of cases in a open system file.  Some files
do not store the number of cases.  In these instances undef
will be returned.  Therefore, then programmer must check that the
returned value is not undef before using it.
.PP
\fIget_dict ()\fR
.IX Subsection "get_dict ()"
.PP
Returns the dictionary associated with the reader.
.PP
\fIget_next_case ()\fR
.IX Subsection "get_next_case ()"
.PP
Retrieves the next case from the reader.
This method returns an array of scalars, each of which are the values of 
the data in the system file.
The first call to \f(CW\*(C`get_next_case\*(C'\fR after \f(CW\*(C`open\*(C'\fR has been called retrieves
the first case in the system file.  Each subsequent call retrieves the next
case.  If there are no more cases to be read, the function returns an empty
list.
.PP
If the case contains system missing values, these values are set to the 
empty string.
.SS "Miscellaneous subroutines"
.IX Subsection "Miscellaneous subroutines"
The following subroutines provide (hopefully) useful information about the 
values retrieved from a reader.
.PP
\fIPSPP::format_value ($value, \f(CI$variable\fI)\fR
.IX Subsection "PSPP::format_value ($value, $variable)"
.PP
Returns a scalar containing a string representing \f(CW\*(C`value\*(C'\fR formatted according 
to the print format of \f(CW\*(C`variable\*(C'\fR.
In the most common usage,  \f(CW\*(C`value\*(C'\fR should be a value of \f(CW\*(C`variable\*(C'\fR.
.PP
\fIPSPP::value_is_missing ($value, \f(CI$variable\fI)\fR
.IX Subsection "PSPP::value_is_missing ($value, $variable)"
.PP
Returns non-zero if \f(CW\*(C`value\*(C'\fR is either system missing, or if it matches the 
user missing criteria for \f(CW\*(C`variable\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
John Darrington, <john@darrington.wattle.id.au>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2007, 2008, 2009 by Free Software Foundation
.PP
This program is free software: you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
