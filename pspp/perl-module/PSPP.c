/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of PSPP.xs. Do not edit this file, edit PSPP.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "PSPP.xs"
/* PSPP - computes sample statistics.
   Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301, USA. */


#include <config.h>

/* The Gnulib "strftime" module defines my_strftime in <config.h> for use by
   gl/strftime.c.  Perl also defines my_strftime in embed.h for some other
   purpose.  The former definition doesn't matter in this file, so suppress it
   to avoid a compiler warning. */
#undef my_strftime

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include "minmax.h"
#include <libpspp/hmap.h>
#include <libpspp/hash-functions.h>
#include <libpspp/message.h>
#include <libpspp/version.h>
#include <libpspp/i18n.h>
#include <gl/xalloc.h>
#include <data/dictionary.h>
#include <data/case.h>
#include <data/casereader.h>
#include <data/casewriter.h>
#include <data/variable.h>
#include <data/attributes.h>
#include <data/file-handle-def.h>
#include <data/identifier.h>
#include <data/settings.h>
#include <data/sys-file-writer.h>
#include <data/value.h>
#include <data/vardict.h>
#include <data/value-labels.h>
#include <data/format.h>
#include <data/data-in.h>
#include <data/data-out.h>
#include <string.h>

typedef struct fmt_spec input_format ;
typedef struct fmt_spec output_format ;


/*  A thin wrapper around sfm_writer */
struct syswriter_info
{
  bool opened;

  /* A pointer to the writer. The writer is owned by the struct */
  struct casewriter *writer;

  /* A pointer to the dictionary. Owned externally */
  const struct pspp_dict *dict;

  /* The scalar containing the dictionary */
  SV *dict_sv;
};


/*  A thin wrapper around sfm_reader */
struct sysreader_info
{
  struct any_read_info opts;

  /* A pointer to the reader. The reader is owned by the struct */
  struct casereader *reader;

  /* A pointer to the dictionary. */
  struct pspp_dict *dict;
};


struct input_format {
  struct hmap_node hmap_node;   /* In struct pspp_dict's input_formats map. */
  const struct variable *var;
  struct fmt_spec input_format;
};

/* A thin wrapper around struct dictionary.*/
struct pspp_dict {
  struct dictionary *dict;
  struct hmap input_formats;	/* Contains struct input_format. */
};


/*  A message handler which writes messages to PSPP::errstr */
static void
message_handler (const struct msg *m, void *aux)
{
 SV *errstr = get_sv("PSPP::errstr", TRUE);
 sv_setpv (errstr, m->text);
}

static int
sysfile_close (struct syswriter_info *swi)
{
  int retval ;
  if ( ! swi->opened )
    return 0;

  retval = casewriter_destroy (swi->writer);
  if (retval > 0 )
    swi->opened = false;

  return retval;
}

static void
scalar_to_value (union value *val, SV *scalar, const struct variable *var)
{
  if ( var_is_numeric (var))
    {
	if ( SvNOK (scalar) || SvIOK (scalar) )
	   val->f = SvNV (scalar);
	else
	   val->f = SYSMIS;
    }
  else
    {
	STRLEN len;
	const char *p = SvPV (scalar, len);
	int width = var_get_width (var);
	value_set_missing (val, width);
	memcpy (value_str_rw (val, width), p, len);
    }
}


static SV *
value_to_scalar (const union value *val, const struct variable *var)
{
  if ( var_is_numeric (var))
    {
      if ( var_is_value_missing (var, val, MV_SYSTEM))
	return newSVpvn ("", 0);

      return newSVnv (val->f);
    }
  else
    {
      int width = var_get_width (var);
      return newSVpvn (value_str (val, width), width);
    }
}


static void
make_value_from_scalar (union value *uv, SV *val, const struct variable *var)
{
 value_init (uv, var_get_width (var));
 scalar_to_value (uv, val, var);
}

static struct pspp_dict *
create_pspp_dict (struct dictionary *dict)
{
  struct pspp_dict *pspp_dict = xmalloc (sizeof *pspp_dict);
  pspp_dict->dict = dict;
  hmap_init (&pspp_dict->input_formats);
  return pspp_dict;
}

static const struct fmt_spec *
find_input_format (const struct pspp_dict *dict, const struct variable *var)
{
  struct input_format *input_format;

  HMAP_FOR_EACH_IN_BUCKET (input_format, struct input_format, hmap_node,
                           hash_pointer (var, 0), &dict->input_formats)
    if (input_format->var == var)
      return &input_format->input_format;

  return NULL;
}


#line 206 "PSPP.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 350 "PSPP.c"

XS_EUPXS(XS_PSPP_onBoot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP_onBoot)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ver");
    {
	const char *	ver = (const char *)SvPV_nolen(ST(0))
;
#line 206 "PSPP.xs"
 /* Check that the version is correct up to the length of 'ver'.
    This allows PSPP autobuilders to add a "-build#" suffix to the
    PSPP version without causing failures here. */
 assert (0 == strncmp (ver, bare_version, strlen (ver)));

 i18n_init ();
 msg_set_handler (message_handler, NULL);
 settings_init ();
 fh_init ();
#line 371 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP_format_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP_format_value)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "val, var");
    {
	SV *	val = ST(0)
;
	struct variable *	var;
	SV *	RETVAL;

	if (SvROK(ST(1))) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::format_value",
			"var")
;
#line 221 "PSPP.xs"
 SV *ret;
 const struct fmt_spec *fmt = var_get_print_format (var);
 union value uv;
 char *s;
 make_value_from_scalar (&uv, val, var);
 s = data_out (&uv, var_get_encoding (var), fmt);
 value_destroy (&uv, var_get_width (var));
 ret = newSVpv (s, fmt->w);
 free (s);
 RETVAL = ret;
#line 409 "PSPP.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP_value_is_missing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP_value_is_missing)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "val, var");
    {
	SV *	val = ST(0)
;
	struct variable *	var;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(1))) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::value_is_missing",
			"var")
;
#line 240 "PSPP.xs"
 union value uv;
 int ret;
 make_value_from_scalar (&uv, val, var);
 ret = var_is_value_missing (var, &uv, MV_ANY);
 value_destroy (&uv, var_get_width (var));
 RETVAL = ret;
#line 446 "PSPP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Dict_pxs_dict_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_pxs_dict_new)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	struct pspp_dict *	RETVAL;
#line 256 "PSPP.xs"
 RETVAL = create_pspp_dict (dict_create ("UTF-8"));
#line 463 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Dict_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dict");
    {
	struct pspp_dict *	dict;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::DESTROY",
			"dict")
;
#line 265 "PSPP.xs"
 if (dict != NULL)
   {
     struct input_format *input_format, *next_input_format;

     HMAP_FOR_EACH_SAFE (input_format, next_input_format,
			 struct input_format, hmap_node, &dict->input_formats)
       {
         hmap_delete (&dict->input_formats, &input_format->hmap_node);
	 free (input_format);
       }
     hmap_destroy (&dict->input_formats);
     dict_destroy (dict->dict);
     free (dict);
   }
#line 508 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Dict_get_var_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_get_var_cnt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dict");
    {
	struct pspp_dict *	dict;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::get_var_cnt",
			"dict")
;
#line 284 "PSPP.xs"
 RETVAL = dict_get_var_cnt (dict->dict);
#line 536 "PSPP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Dict_set_label); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_set_label)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dict, label");
    {
	struct pspp_dict *	dict;
	char *	label = (char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::set_label",
			"dict")
;
#line 293 "PSPP.xs"
 dict_set_label (dict->dict, label);
#line 565 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Dict_set_documents); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_set_documents)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dict, docs");
    {
	struct pspp_dict *	dict;
	char *	docs = (char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::set_documents",
			"dict")
;
#line 300 "PSPP.xs"
 dict_set_documents_string (dict->dict, docs);
#line 593 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Dict_add_document); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_add_document)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dict, doc");
    {
	struct pspp_dict *	dict;
	char *	doc = (char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::add_document",
			"dict")
;
#line 308 "PSPP.xs"
 dict_add_document_line (dict->dict, doc, false);
#line 621 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Dict_clear_documents); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_clear_documents)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dict");
    {
	struct pspp_dict *	dict;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::clear_documents",
			"dict")
;
#line 315 "PSPP.xs"
 dict_clear_documents (dict->dict);
#line 647 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Dict_set_weight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_set_weight)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dict, var");
    {
	struct pspp_dict *	dict;
	struct variable *	var;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::set_weight",
			"dict")
;

	if (SvROK(ST(1))) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::set_weight",
			"var")
;
#line 323 "PSPP.xs"
 dict_set_weight (dict->dict, var);
#line 684 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Dict_pxs_get_variable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_pxs_get_variable)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dict, idx");
    {
	struct pspp_dict *	dict;
	SV *	idx = ST(1)
;
	struct variable *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::pxs_get_variable",
			"dict")
;
#line 331 "PSPP.xs"
 SV *errstr = get_sv("PSPP::errstr", TRUE);
 sv_setpv (errstr, "");
 if ( SvIV (idx) >= dict_get_var_cnt (dict->dict))
  {
    sv_setpv (errstr, "The dictionary doesn't have that many variables.");
    XSRETURN_UNDEF;
  }
#line 719 "PSPP.c"
#line 339 "PSPP.xs"
 RETVAL = dict_get_var (dict->dict, SvIV (idx));
#line 722 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Dict_pxs_get_var_by_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Dict_pxs_get_var_by_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dict, name");
    {
	struct pspp_dict *	dict;
	const char *	name = (const char *)SvPV_nolen(ST(1))
;
	struct variable *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Dict::pxs_get_var_by_name",
			"dict")
;
#line 349 "PSPP.xs"
 SV *errstr = get_sv("PSPP::errstr", TRUE);
 sv_setpv (errstr, "");
#line 758 "PSPP.c"
#line 352 "PSPP.xs"
 struct variable *var = dict_lookup_var (dict->dict, name);
 if ( ! var )
      sv_setpv (errstr, "No such variable.");
 RETVAL = var;
#line 764 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_pxs_dict_create_var); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_pxs_dict_create_var)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dict, name, ip_fmt");
    {
	struct pspp_dict *	dict;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	input_format	ip_fmt;
	struct variable *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::pxs_dict_create_var",
			"dict")
;

 {
   HV *hv = (HV *) SvRV (ST(2));
   SV** the_format = hv_fetch (hv, "fmt", 3, 0);
   SV** decimals = hv_fetch (hv, "decimals", 8, 0);
   SV** width = hv_fetch (hv, "width", 5, 0);
   ip_fmt.type = the_format ? SvIV (*the_format) : FMT_F;
   ip_fmt.w    = width ? SvIV (*width) : 8;
   ip_fmt.d    = decimals ? SvIV (*decimals) :
     fmt_takes_decimals (ip_fmt.type) ?
     MIN (2, fmt_max_input_decimals (ip_fmt.type, ip_fmt.w)) : 0;
   if ( ! fmt_check_input (&ip_fmt))
   {
	char buf[FMT_STRING_LEN_MAX + 1];
        fmt_to_string (&ip_fmt, buf);
  	croak ("%s is an invalid input format", buf);
   }
 }
;
#line 369 "PSPP.xs"
 SV *errstr = get_sv("PSPP::errstr", TRUE);
 sv_setpv (errstr, "");
 if ( ! id_is_plausible (name, false))
  {
    sv_setpv (errstr, "The variable name is not valid.");
    XSRETURN_UNDEF;
  }
#line 825 "PSPP.c"
#line 377 "PSPP.xs"
 struct fmt_spec op_fmt;
 struct input_format *input_format;

 struct variable *v;
 op_fmt = fmt_for_output_from_input (&ip_fmt);
 v = dict_create_var (dict->dict, name,
	fmt_is_string (op_fmt.type) ? op_fmt.w : 0);
 if ( NULL == v )
  {
    sv_setpv (errstr, "The variable could not be created (probably already exists).");
    XSRETURN_UNDEF;
  }
 var_set_both_formats (v, &op_fmt);

 input_format = xmalloc (sizeof *input_format);
 input_format->var = v;
 input_format->input_format = ip_fmt;
 hmap_insert (&dict->input_formats, &input_format->hmap_node,
              hash_pointer (v, 0));

 RETVAL = v;
#line 848 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_set_missing_values); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_set_missing_values)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "var, v1, ...");
    {
	struct variable *	var;
	SV *	v1 = ST(1)
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::set_missing_values",
			"var")
;
#line 407 "PSPP.xs"
 int i;
 union value val[3];

 if ( items > 4 )
  croak ("No more than 3 missing values are permitted");

 for (i = 0; i < items - 1; ++i)
   scalar_to_value (&val[i], ST(i+1), var);
#line 891 "PSPP.c"
#line 416 "PSPP.xs"
 struct missing_values mv;
 mv_init (&mv, var_get_width (var));
 for (i = 0 ; i < items - 1; ++i )
   mv_add_value (&mv, &val[i]);
 var_set_missing_values (var, &mv);
#line 898 "PSPP.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_set_label); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_set_label)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "var, label");
    {
	struct variable *	var;
	char *	label = (char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::set_label",
			"var")
;
#line 428 "PSPP.xs"
  var_set_label (var, label);
#line 926 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Var_clear_value_labels); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_clear_value_labels)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::clear_value_labels",
			"var")
;
#line 435 "PSPP.xs"
 var_clear_value_labels (var);
#line 952 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Var_get_write_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_get_write_format)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::get_write_format",
			"var")
;
#line 441 "PSPP.xs"
 HV *fmthash = (HV *) sv_2mortal ((SV *) newHV());
 const struct fmt_spec *fmt = var_get_write_format (var);

 hv_store (fmthash, "fmt", 3, newSVnv (fmt->type), 0);
 hv_store (fmthash, "decimals", 8, newSVnv (fmt->d), 0);
 hv_store (fmthash, "width", 5, newSVnv (fmt->w), 0);

 RETVAL = newRV ((SV *) fmthash);
#line 986 "PSPP.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_get_print_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_get_print_format)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::get_print_format",
			"var")
;
#line 456 "PSPP.xs"
 HV *fmthash = (HV *) sv_2mortal ((SV *) newHV());
 const struct fmt_spec *fmt = var_get_print_format (var);

 hv_store (fmthash, "fmt", 3, newSVnv (fmt->type), 0);
 hv_store (fmthash, "decimals", 8, newSVnv (fmt->d), 0);
 hv_store (fmthash, "width", 5, newSVnv (fmt->w), 0);

 RETVAL = newRV ((SV *) fmthash);
#line 1022 "PSPP.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_pxs_set_write_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_pxs_set_write_format)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "var, fmt");
    {
	struct variable *	var;
	output_format	fmt;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::pxs_set_write_format",
			"var")
;

 {
   HV *hv = (HV *) SvRV (ST(1));
   SV** the_format = hv_fetch (hv, "fmt", 3, 0);
   SV** decimals = hv_fetch (hv, "decimals", 8, 0);
   SV** width = hv_fetch (hv, "width", 5, 0);
   fmt.type = the_format ? SvIV (*the_format) : FMT_F;
   fmt.w    = width ? SvIV (*width) : 8;
   fmt.d    = decimals ? SvIV (*decimals) :
     fmt_takes_decimals (fmt.type) ?
     MIN (2, fmt_max_output_decimals (fmt.type, fmt.w)) : 0;
   if ( ! fmt_check_output (&fmt))
   {
	char buf[FMT_STRING_LEN_MAX + 1];
        fmt_to_string (&fmt, buf);
  	croak ("%s is an invalid output format", buf);
   }
 }
;
#line 473 "PSPP.xs"
 var_set_write_format (var, &fmt);
#line 1070 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Var_pxs_set_print_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_pxs_set_print_format)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "var, fmt");
    {
	struct variable *	var;
	output_format	fmt;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::pxs_set_print_format",
			"var")
;

 {
   HV *hv = (HV *) SvRV (ST(1));
   SV** the_format = hv_fetch (hv, "fmt", 3, 0);
   SV** decimals = hv_fetch (hv, "decimals", 8, 0);
   SV** width = hv_fetch (hv, "width", 5, 0);
   fmt.type = the_format ? SvIV (*the_format) : FMT_F;
   fmt.w    = width ? SvIV (*width) : 8;
   fmt.d    = decimals ? SvIV (*decimals) :
     fmt_takes_decimals (fmt.type) ?
     MIN (2, fmt_max_output_decimals (fmt.type, fmt.w)) : 0;
   if ( ! fmt_check_output (&fmt))
   {
	char buf[FMT_STRING_LEN_MAX + 1];
        fmt_to_string (&fmt, buf);
  	croak ("%s is an invalid output format", buf);
   }
 }
;
#line 481 "PSPP.xs"
 var_set_print_format (var, &fmt);
#line 1116 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Var_pxs_set_output_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_pxs_set_output_format)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "var, fmt");
    {
	struct variable *	var;
	output_format	fmt;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::pxs_set_output_format",
			"var")
;

 {
   HV *hv = (HV *) SvRV (ST(1));
   SV** the_format = hv_fetch (hv, "fmt", 3, 0);
   SV** decimals = hv_fetch (hv, "decimals", 8, 0);
   SV** width = hv_fetch (hv, "width", 5, 0);
   fmt.type = the_format ? SvIV (*the_format) : FMT_F;
   fmt.w    = width ? SvIV (*width) : 8;
   fmt.d    = decimals ? SvIV (*decimals) :
     fmt_takes_decimals (fmt.type) ?
     MIN (2, fmt_max_output_decimals (fmt.type, fmt.w)) : 0;
   if ( ! fmt_check_output (&fmt))
   {
	char buf[FMT_STRING_LEN_MAX + 1];
        fmt_to_string (&fmt, buf);
  	croak ("%s is an invalid output format", buf);
   }
 }
;
#line 488 "PSPP.xs"
 var_set_both_formats (var, &fmt);
#line 1162 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Var_add_value_label); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_add_value_label)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "var, key, label");
    {
	struct variable *	var;
	SV *	key = ST(1)
;
	char *	label = (char *)SvPV_nolen(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::add_value_label",
			"var")
;
#line 497 "PSPP.xs"
 SV *errstr = get_sv("PSPP::errstr", TRUE);
 sv_setpv (errstr, "");
#line 1195 "PSPP.c"
#line 500 "PSPP.xs"
 union value the_value;
 int width = var_get_width (var);
 int ok;

 value_init (&the_value, width);
 if ( var_is_numeric (var))
 {
  if ( ! looks_like_number (key))
    {
      sv_setpv (errstr, "Cannot add label with string key to a numeric variable");
      value_destroy (&the_value, width);
      XSRETURN_IV (0);
    }
  the_value.f = SvNV (key);
 }
 else
 {
  value_copy_str_rpad (&the_value, width, SvPV_nolen(key), ' ');
 }
 ok = var_add_value_label (var, &the_value, label);
 value_destroy (&the_value, width);
 if (!ok)
 {
   sv_setpv (errstr, "Something went wrong");
   XSRETURN_IV (0);
 }
 XSRETURN_IV (1);
#line 1224 "PSPP.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_get_attributes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_get_attributes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::get_attributes",
			"var")
;
#line 533 "PSPP.xs"
 HV *attrhash = (HV *) sv_2mortal ((SV *) newHV());

 struct attrset *as = var_get_attributes (var);

 if ( as )
   {
     struct attrset_iterator iter;
     struct attribute *attr;

     for (attr = attrset_first (as, &iter);
	  attr;
	  attr = attrset_next (as, &iter))
       {
	 int i;
	 const char *name = attribute_get_name (attr);

	 AV *values = newAV ();

	 for (i = 0 ; i < attribute_get_n_values (attr); ++i )
	   {
	     const char *value = attribute_get_value (attr, i);
	     av_push (values, newSVpv (value, 0));
	   }

	 hv_store (attrhash, name, strlen (name),
		   newRV_noinc ((SV*) values), 0);
       }
   }

 RETVAL = newRV ((SV *) attrhash);
#line 1280 "PSPP.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_get_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_get_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::get_name",
			"var")
;
#line 571 "PSPP.xs"
 RETVAL = var_get_name (var);
#line 1310 "PSPP.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_get_label); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_get_label)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::get_label",
			"var")
;
#line 580 "PSPP.xs"
 RETVAL = var_get_label (var);
#line 1339 "PSPP.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Var_get_value_labels); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Var_get_value_labels)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "var");
    {
	struct variable *	var;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    var = INT2PTR(struct variable *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Var::get_value_labels",
			"var")
;
#line 589 "PSPP.xs"
 HV *labelhash = (HV *) sv_2mortal ((SV *) newHV());
 const struct val_lab *vl;
 struct val_labs_iterator *viter = NULL;
 const struct val_labs *labels = var_get_value_labels (var);

 if ( labels )
   {
     for (vl = val_labs_first (labels);
	  vl;
	  vl = val_labs_next (labels, vl))
       {
	 SV *sv = value_to_scalar (&vl->value, var);
	 STRLEN len;
	 const char *s = SvPV (sv, len);
	 hv_store (labelhash, s, len, newSVpv (val_lab_get_label (vl), 0), 0);
       }
   }

 RETVAL = newRV ((SV *) labelhash);
#line 1385 "PSPP.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Sysfile_pxs_create_sysfile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Sysfile_pxs_create_sysfile)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "name, dict, opts_hr");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	struct pspp_dict *	dict;
	SV *	opts_hr = ST(2)
;
	struct syswriter_info *	RETVAL;

	if (SvROK(ST(1))) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    dict = INT2PTR(struct pspp_dict *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Sysfile::pxs_create_sysfile",
			"dict")
;
#line 622 "PSPP.xs"
 SV *dict_sv = ST(1);
 struct sfm_write_options opts;
 if (!SvROK (opts_hr))
  {
    opts = sfm_writer_default_options ();
  }
 else
  {
    HV *opt_h = (HV *) SvRV (opts_hr);
    SV** readonly = hv_fetch(opt_h, "readonly", 8, 0);
    SV** compress = hv_fetch(opt_h, "compress", 8, 0);
    SV** version = hv_fetch(opt_h, "version", 7, 0);

    opts.create_writeable = readonly ? ! SvIV (*readonly) : true;
    opts.compression = (compress && SvIV (*compress)
                        ? ANY_COMP_SIMPLE
			: ANY_COMP_NONE);
    opts.version = version ? SvIV (*version) : 3 ;
  }
#line 1436 "PSPP.c"
#line 642 "PSPP.xs"
 struct file_handle *fh =
   fh_create_file (NULL, name, "UTF-8", fh_default_properties () );
 struct syswriter_info *swi = xmalloc (sizeof (*swi));
 swi->writer = sfm_open_writer (fh, dict->dict, opts);
 swi->dict = dict;
 swi->opened = true;
 swi->dict_sv = dict_sv;
 SvREFCNT_inc (swi->dict_sv);

 RETVAL = swi;
#line 1448 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Sysfile_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Sysfile_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "swi");
    {
	struct syswriter_info *	swi;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    swi = INT2PTR(struct syswriter_info *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Sysfile::close",
			"swi")
;
#line 659 "PSPP.xs"
 RETVAL = sysfile_close (swi);
#line 1482 "PSPP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Sysfile_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Sysfile_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "swi");
    {
	struct syswriter_info *	swi;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    swi = INT2PTR(struct syswriter_info *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Sysfile::DESTROY",
			"swi")
;
#line 667 "PSPP.xs"
 sysfile_close (swi);
 SvREFCNT_dec (swi->dict_sv);
 free (swi);
#line 1511 "PSPP.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PSPP__Sysfile_append_case); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Sysfile_append_case)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "swi, ccase");
    {
	struct syswriter_info *	swi;
	SV *	ccase = ST(1)
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    swi = INT2PTR(struct syswriter_info *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Sysfile::append_case",
			"swi")
;
#line 676 "PSPP.xs"
 SV *errstr = get_sv("PSPP::errstr", TRUE);
 sv_setpv (errstr, "");
 if ( (!SvROK(ccase)))
  {
    XSRETURN_UNDEF;
  }
#line 1546 "PSPP.c"
#line 683 "PSPP.xs"
 int i = 0;
 AV *av_case = (AV*) SvRV (ccase);

 const struct variable **vv;
 size_t nv;
 struct ccase *c;
 SV *sv;

 if ( av_len (av_case) >= dict_get_var_cnt (swi->dict->dict))
   XSRETURN_UNDEF;

 c =  case_create (dict_get_proto (swi->dict->dict));

 dict_get_vars (swi->dict->dict, &vv, &nv,
                1u << DC_ORDINARY | 1u << DC_SYSTEM);

 for (sv = av_shift (av_case); SvOK (sv);  sv = av_shift (av_case))
 {
    const struct variable *v = vv[i++];
    const struct fmt_spec *ifmt = find_input_format (swi->dict, v);

    /* If an input format has been set, then use it.
       Otherwise just convert the raw value.
    */
    if ( ifmt )
      {
	struct substring ss = ss_cstr (SvPV_nolen (sv));
	char *error;
	bool ok;

	error = data_in (ss, SvUTF8(sv) ? UTF8: "iso-8859-1", ifmt->type,
 	       	         case_data_rw (c, v), var_get_width (v),
			 dict_get_encoding (swi->dict->dict));
        ok = error == NULL;
        free (error);

	if ( !ok )
	  {
	    RETVAL = 0;
	    goto finish;
	  }
      }
    else
      {
	scalar_to_value (case_data_rw (c, v), sv, v);
      }
 }

 /* The remaining variables must be sysmis or blank string */
 while (i < dict_get_var_cnt (swi->dict->dict))
 {
   const struct variable *v = vv[i++];
   union value *val = case_data_rw (c, v);
   value_set_missing (val, var_get_width (v));
 }
 casewriter_write (swi->writer, c);
 RETVAL = 1;
 finish:
 free (vv);
#line 1607 "PSPP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Reader_pxs_open_sysfile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Reader_pxs_open_sysfile)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	struct sysreader_info *	RETVAL;
#line 754 "PSPP.xs"
 struct casereader *reader;
 struct sysreader_info *sri = NULL;
 struct file_handle *fh =
   fh_create_file (NULL, name, "UTF-8", fh_default_properties () );
 struct dictionary *dict;

 sri = xmalloc (sizeof (*sri));
 sri->reader = any_reader_open_and_decode (fh, NULL, &dict, &sri->opts);
 if (sri->reader)
   sri->dict = create_pspp_dict (dict);
 else
   {
     free (sri);
     sri = NULL;
   }

 RETVAL = sri;
#line 1642 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Reader_pxs_get_dict); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Reader_pxs_get_dict)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "reader");
    {
	struct sysreader_info *	reader;
	struct pspp_dict *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    reader = INT2PTR(struct sysreader_info *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Reader::pxs_get_dict",
			"reader")
;
#line 779 "PSPP.xs"
 RETVAL = reader->dict;
#line 1675 "PSPP.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, Nullch, (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Reader_get_case_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Reader_get_case_cnt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sfr");
    {
	struct sysreader_info *	sfr;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sfr = INT2PTR(struct sysreader_info *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Reader::get_case_cnt",
			"sfr")
;
#line 787 "PSPP.xs"
 SV *ret;
 casenumber n = casereader_get_case_cnt (sfr->reader);
 if (n == CASENUMBER_MAX)
  ret = &PL_sv_undef;
 else 
  ret = newSViv (n);
 RETVAL = ret;
#line 1714 "PSPP.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PSPP__Reader_get_next_case); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PSPP__Reader_get_next_case)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sfr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	struct sysreader_info *	sfr;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sfr = INT2PTR(struct sysreader_info *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"PSPP::Reader::get_next_case",
			"sfr")
;
#line 803 "PSPP.xs"
 struct ccase *c;

 if ((c = casereader_read (sfr->reader)) != NULL)
 {
  int v;

  EXTEND (SP, dict_get_var_cnt (sfr->dict->dict));
  for (v = 0; v < dict_get_var_cnt (sfr->dict->dict); ++v )
    {
      const struct variable *var = dict_get_var (sfr->dict->dict, v);
      const union value *val = case_data (c, var);

      PUSHs (sv_2mortal (value_to_scalar (val, var)));
    }

  case_unref (c);
 }
#line 1760 "PSPP.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_PSPP); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_PSPP)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("PSPP::onBoot", XS_PSPP_onBoot, file, "$");
        (void)newXSproto_portable("PSPP::format_value", XS_PSPP_format_value, file, "$$");
        (void)newXSproto_portable("PSPP::value_is_missing", XS_PSPP_value_is_missing, file, "$$");
        (void)newXSproto_portable("PSPP::Dict::pxs_dict_new", XS_PSPP__Dict_pxs_dict_new, file, "");
        (void)newXSproto_portable("PSPP::Dict::DESTROY", XS_PSPP__Dict_DESTROY, file, "$");
        (void)newXSproto_portable("PSPP::Dict::get_var_cnt", XS_PSPP__Dict_get_var_cnt, file, "$");
        (void)newXSproto_portable("PSPP::Dict::set_label", XS_PSPP__Dict_set_label, file, "$$");
        (void)newXSproto_portable("PSPP::Dict::set_documents", XS_PSPP__Dict_set_documents, file, "$$");
        (void)newXSproto_portable("PSPP::Dict::add_document", XS_PSPP__Dict_add_document, file, "$$");
        (void)newXSproto_portable("PSPP::Dict::clear_documents", XS_PSPP__Dict_clear_documents, file, "$");
        (void)newXSproto_portable("PSPP::Dict::set_weight", XS_PSPP__Dict_set_weight, file, "$$");
        (void)newXSproto_portable("PSPP::Dict::pxs_get_variable", XS_PSPP__Dict_pxs_get_variable, file, "$$");
        (void)newXSproto_portable("PSPP::Dict::pxs_get_var_by_name", XS_PSPP__Dict_pxs_get_var_by_name, file, "$$");
        (void)newXSproto_portable("PSPP::Var::pxs_dict_create_var", XS_PSPP__Var_pxs_dict_create_var, file, "$$$");
        (void)newXSproto_portable("PSPP::Var::set_missing_values", XS_PSPP__Var_set_missing_values, file, "$$;@");
        (void)newXSproto_portable("PSPP::Var::set_label", XS_PSPP__Var_set_label, file, "$$");
        (void)newXSproto_portable("PSPP::Var::clear_value_labels", XS_PSPP__Var_clear_value_labels, file, "$");
        (void)newXSproto_portable("PSPP::Var::get_write_format", XS_PSPP__Var_get_write_format, file, "$");
        (void)newXSproto_portable("PSPP::Var::get_print_format", XS_PSPP__Var_get_print_format, file, "$");
        (void)newXSproto_portable("PSPP::Var::pxs_set_write_format", XS_PSPP__Var_pxs_set_write_format, file, "$$");
        (void)newXSproto_portable("PSPP::Var::pxs_set_print_format", XS_PSPP__Var_pxs_set_print_format, file, "$$");
        (void)newXSproto_portable("PSPP::Var::pxs_set_output_format", XS_PSPP__Var_pxs_set_output_format, file, "$$");
        (void)newXSproto_portable("PSPP::Var::add_value_label", XS_PSPP__Var_add_value_label, file, "$$$");
        (void)newXSproto_portable("PSPP::Var::get_attributes", XS_PSPP__Var_get_attributes, file, "$");
        (void)newXSproto_portable("PSPP::Var::get_name", XS_PSPP__Var_get_name, file, "$");
        (void)newXSproto_portable("PSPP::Var::get_label", XS_PSPP__Var_get_label, file, "$");
        (void)newXSproto_portable("PSPP::Var::get_value_labels", XS_PSPP__Var_get_value_labels, file, "$");
        (void)newXSproto_portable("PSPP::Sysfile::pxs_create_sysfile", XS_PSPP__Sysfile_pxs_create_sysfile, file, "$$$");
        (void)newXSproto_portable("PSPP::Sysfile::close", XS_PSPP__Sysfile_close, file, "$");
        (void)newXSproto_portable("PSPP::Sysfile::DESTROY", XS_PSPP__Sysfile_DESTROY, file, "$");
        (void)newXSproto_portable("PSPP::Sysfile::append_case", XS_PSPP__Sysfile_append_case, file, "$$");
        (void)newXSproto_portable("PSPP::Reader::pxs_open_sysfile", XS_PSPP__Reader_pxs_open_sysfile, file, "$");
        (void)newXSproto_portable("PSPP::Reader::pxs_get_dict", XS_PSPP__Reader_pxs_get_dict, file, "$");
        (void)newXSproto_portable("PSPP::Reader::get_case_cnt", XS_PSPP__Reader_get_case_cnt, file, "$");
        (void)newXSproto_portable("PSPP::Reader::get_next_case", XS_PSPP__Reader_get_next_case, file, "$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

